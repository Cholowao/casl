{"title":"Ability to database query","categories":["advanced"],"order":75,"meta":{"keywords":null,"description":null},"content":"<p>Sometimes you need to restrict which records are returned from the database based on what the user is able to do in the app. <code>@casl/ability/extra</code> provides <code>rulesToQuery</code> helper function which helps to convert rules into a particular database's query. This function accepts 4 arguments:</p>\n<ol>\n<li>An instance of <code>PureAbility</code></li>\n<li><code>action</code> for which you want to get rules</li>\n<li><code>subjectType</code> which you plan to query</li>\n<li>conversion function which takes rule as the only argument and returns database query chunk</li>\n</ol>\n<p>The helper aggregates all query chunks into a single object that has <code>$or</code> and <code>$and</code> properties. Query chunk for direct rules are collected in <code>$or</code> array and inverted - in <code>$and</code> array. <strong>This function returns <code>null</code></strong> if the provided ability does not allow to perform the provided action on the provided subject type.</p>\n<blockquote>\n<p>See <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;package/casl-mongoose&quot;}\">@casl/mongoose</app-link> to get details about integration with <a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"noopener nofollow\">MongoDB</a></p>\n</blockquote>\n<p>To understand the logic better let's implement <strong>a basic helper</strong> for <a href=\"https://sequelize.org/\" target=\"_blank\" rel=\"noopener nofollow\">sequelize</a>.</p>\n<pre><code data-filename=\"toSequelizeQuery.js\" class=\"language-js\"><span class=\"hljs-keyword\">const</span> { rulesToQuery } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;@casl/ability/extra&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> { Op } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;sequelize&#x27;</span>);\n\n<span class=\"hljs-comment\">/**\n * Tricky way to walk recursively over deeply nested object.\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Parameters\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">symbolize</span>(<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">JSON</span>.parse(<span class=\"hljs-built_in\">JSON</span>.stringify(query), <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">keyToSymbol</span>(<span class=\"hljs-params\">key, value</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;$&#x27;</span>) {\n      <span class=\"hljs-keyword\">const</span> symbol = Op[key.slice(<span class=\"hljs-number\">1</span>)];\n      <span class=\"hljs-built_in\">this</span>[symbol] = value;\n      <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-keyword\">return</span> value;\n  });\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ruleToSequelize</span>(<span class=\"hljs-params\">rule</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> rule.inverted ? { <span class=\"hljs-attr\">$not</span>: rule.conditions } : rule.conditions;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toSequelizeQuery</span>(<span class=\"hljs-params\">ability, subject, action</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> query = rulesToQuery(ability, action, subject, ruleToSequelize);\n  <span class=\"hljs-keyword\">return</span> query === <span class=\"hljs-literal\">null</span> ? query : symbolize(query);\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">accessibleBy</span>(<span class=\"hljs-params\">ability, action = <span class=\"hljs-string\">&#x27;read&#x27;</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> query = toSequelizeQuery(ability, action, <span class=\"hljs-built_in\">this</span>.name);\n\n  <span class=\"hljs-keyword\">if</span> (query === <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// there is no accessible records, so no need to send query to db</span>\n    <span class=\"hljs-keyword\">return</span> [];\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.findAll({\n    <span class=\"hljs-attr\">where</span>: query;\n  });\n}\n\n<span class=\"hljs-built_in\">module</span>.exports = {\n  toSequelizeQuery,\n  accessibleBy,\n};\n</code></pre>\n<p>In this example, we used <code>rulesToQuery</code> to iterate over rules and aggregate sequelize query. <code>$not</code> operator is used to invert the result of inverted rules' conditions. As of sequelize v6, operator aliases are removed (<a href=\"https://github.com/sequelize/sequelize/issues/10820\" target=\"_blank\" rel=\"noopener nofollow\">sequelize#10820</a>), so we need to convert string based keys into symbols. To do so, we used a trick of stringifying and parsing JSON object with custom <code>reviver</code> argument, which detects keys that starts with <code>$</code> and replaces them with the respective symbol.</p>\n<p>Then, we can use this function to define static method or scope in your model. Here, we will define static method because its usage looks more natural and readable than custom scope:</p>\n<pre><code data-filename=\"Article.js\" class=\"language-js\"><span class=\"hljs-keyword\">const</span> { Model, DataTypes } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;sequelize&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> { accessibleBy } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./toSequelizeQuery&#x27;</span>);\n\n<span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\">(<span class=\"hljs-params\">sequelize</span>) =&gt;</span> {\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Article</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Model</span> </span>{\n    <span class=\"hljs-keyword\">static</span> accessibleBy = accessibleBy;\n  }\n\n  Article.init({\n    <span class=\"hljs-attr\">title</span>: {\n      <span class=\"hljs-attr\">type</span>: DataTypes.STRING,\n      <span class=\"hljs-attr\">allowNull</span>: <span class=\"hljs-literal\">false</span>\n    },\n    <span class=\"hljs-attr\">published</span>: {\n      <span class=\"hljs-attr\">type</span>: DataTypes.BOOLEAN,\n      <span class=\"hljs-attr\">allowNull</span>: <span class=\"hljs-literal\">false</span>,\n      <span class=\"hljs-attr\">defaultValue</span>: <span class=\"hljs-literal\">false</span>\n    }\n    <span class=\"hljs-comment\">// other columns&#x27; definitions</span>\n  }, {\n    sequelize,\n    <span class=\"hljs-attr\">modelName</span>: Article.name,\n  });\n\n  <span class=\"hljs-keyword\">return</span> Article;\n}\n</code></pre>\n<p>Now we can fetch accessible records using our static method:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> { Sequelize } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;sequelize&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> { defineAbility } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;@casl/ability&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> defineArticle = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./Article&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> sequelize = <span class=\"hljs-keyword\">new</span> Sequelize(<span class=\"hljs-string\">&#x27;sqlite::memory&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> Article = defineArticle(sequelize);\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> ability = defineAbility(<span class=\"hljs-function\"><span class=\"hljs-params\">can</span> =&gt;</span> can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, Article, { <span class=\"hljs-attr\">published</span>: <span class=\"hljs-literal\">true</span> }));\n  <span class=\"hljs-keyword\">const</span> articles = <span class=\"hljs-keyword\">await</span> Article.accessibleBy(ability);\n\n  <span class=\"hljs-built_in\">console</span>.log(articles);\n}\n\nmain().catch(<span class=\"hljs-built_in\">console</span>.error);\n</code></pre>\n<p>This implementation is basic because it doesn't support joins. See <a href=\"https://github.com/stalniy/casl/issues/8\" target=\"_blank\" rel=\"noopener nofollow\">#8</a> to track status of SQL support in CASL.</p>","headings":[],"id":"advanced/ability-to-database-query"}